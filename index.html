<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>Технический анализ SBER с RSI</title>
<style>
  body { font-family: Arial, sans-serif; max-width: 700px; margin: 20px auto; padding: 10px; }
  button { margin-right: 10px; padding: 7px 14px; cursor: pointer; }
  input { width: 70px; padding: 5px; margin-right: 10px; }
  #status { margin: 15px 0; font-weight: bold; }
  #results { white-space: pre-wrap; background: #f9f9f9; padding: 15px; border-radius: 6px; min-height: 200px; }
</style>
</head>
<body>

<h2>Технический анализ SBER (часовой / дневной) с RSI</h2>

<div>
  <button onclick="selectInterval('60')">Часовой</button>
  <button onclick="selectInterval('24')">Дневной</button>
</div>

<div style="margin-top:15px;">
  <label>Комиссия %: <input type="number" id="commission" step="0.01" value="0.1"></label>
  <label>Мин. прибыль %: <input type="number" id="minProfit" step="0.01" value="0.3"></label>
  <button onclick="runAnalysis()">Запустить анализ</button>
</div>

<p id="status">Выберите интервал и нажмите "Запустить анализ"</p>

<div id="results"></div>

<script>
let interval = '60'; // по умолчанию часовой
let candlesData = [];

function selectInterval(val) {
  interval = val;
  document.getElementById('status').textContent = `Выбран интервал: ${interval === '24' ? 'Дневной' : 'Часовой'}`;
  document.getElementById('results').textContent = '';
}

async function fetchData() {
  candlesData = [];
  const years = [2021, 2022, 2023, 2024, 2025];
  const ticker = 'SBER';

  for (const year of years) {
    const from = `${year}-01-01`;
    const till = `${year}-12-31`;
    const url = `https://iss.moex.com/iss/engines/stock/markets/shares/boards/TQBR/securities/${ticker}/candles.json?interval=${interval}&from=${from}&till=${till}&sort_order=asc&limit=1000`;
    try {
      const res = await fetch(url);
      const json = await res.json();
      if (!json.candles || !json.candles.data) continue;
      const cols = json.candles.columns;
      const data = json.candles.data;
      const dateIdx = cols.indexOf('begin');
      const openIdx = cols.indexOf('open');
      const highIdx = cols.indexOf('high');
      const lowIdx = cols.indexOf('low');
      const closeIdx = cols.indexOf('close');
      const volumeIdx = cols.indexOf('volume');

      const yearData = data.map(row => ({
        date: new Date(row[dateIdx]),
        open: row[openIdx],
        high: row[highIdx],
        low: row[lowIdx],
        close: row[closeIdx],
        volume: row[volumeIdx]
      }));
      candlesData = candlesData.concat(yearData);
    } catch(e) {
      console.error(`Ошибка загрузки данных за ${year}`, e);
    }
  }
}

function calculateSMA(data, period) {
  const sma = [];
  for(let i = 0; i < data.length; i++) {
    if(i < period - 1) {
      sma.push(null);
      continue;
    }
    let sum = 0;
    for(let j = i - period + 1; j <= i; j++) {
      sum += data[j].close;
    }
    sma.push(sum / period);
  }
  return sma;
}

// Расчет RSI по классической формуле (14 периодов)
function calculateRSI(data, period = 14) {
  const rsi = [];
  let gains = 0;
  let losses = 0;

  for (let i = 1; i < period; i++) {
    const change = data[i].close - data[i - 1].close;
    if (change > 0) gains += change;
    else losses -= change;
  }

  let avgGain = gains / period;
  let avgLoss = losses / period;
  rsi[period - 1] = 100 - 100 / (1 + avgGain / avgLoss);

  for (let i = period; i < data.length; i++) {
    const change = data[i].close - data[i - 1].close;
    let gain = change > 0 ? change : 0;
    let loss = change < 0 ? -change : 0;

    avgGain = (avgGain * (period - 1) + gain) / period;
    avgLoss = (avgLoss * (period - 1) + loss) / period;

    const rs = avgGain / avgLoss;
    rsi[i] = 100 - 100 / (1 + rs);
  }

  for (let i = 0; i < period - 1; i++) {
    rsi[i] = null;
  }

  return rsi;
}

// Сигналы на покупку/продажу с учетом RSI
function findSignalsWithRSI(shortSMA, longSMA, rsi) {
  const signals = [];
  for (let i = 1; i < shortSMA.length; i++) {
    if (shortSMA[i - 1] === null || longSMA[i - 1] === null || rsi[i] === null) continue;

    // Покупка: пересечение вверх + RSI < 30 (перепроданность)
    if (shortSMA[i - 1] < longSMA[i - 1] && shortSMA[i] > longSMA[i] && rsi[i] < 30) {
      signals.push({ index: i, type: 'buy' });
    }
    // Продажа: пересечение вниз + RSI > 70 (перекупленность)
    else if (shortSMA[i - 1] > longSMA[i - 1] && shortSMA[i] < longSMA[i] && rsi[i] > 70) {
      signals.push({ index: i, type: 'sell' });
    }
  }
  return signals;
}

function findLocalMin(data, startIdx, length) {
  let min = data[startIdx].low;
  for(let i = startIdx; i > startIdx - length && i >= 0; i--) {
    if(data[i].low < min) min = data[i].low;
  }
  return min;
}

function findLocalMax(data, startIdx, length) {
  let max = data[startIdx].high;
  for(let i = startIdx; i > startIdx - length && i >= 0; i--) {
    if(data[i].high > max) max = data[i].high;
  }
  return max;
}

function findExitDate(data, startIdx, targetPrice, stopPrice, type) {
  for(let i = startIdx + 1; i < data.length; i++) {
    if(type === 'buy') {
      if(data[i].low <= stopPrice) return {date: data[i].date, reason: 'Стоп-лосс достигнут'};
      if(data[i].high >= targetPrice) return {date: data[i].date, reason: 'Тейк-профит достигнут'};
    } else {
      if(data[i].high >= stopPrice) return {date: data[i].date, reason: 'Стоп-лосс достигнут'};
      if(data[i].low <= targetPrice) return {date: data[i].date, reason: 'Тейк-профит достигнут'};
    }
  }
  // Если не было выхода - позиция открыта до конца данных
  return {date: null, reason: 'Выход не достигнут'};
}

function analyzeSignals(signals, commissionPct, minProfitPct) {
  const lookback = 10;
  let output = '';

  if(signals.length === 0) {
    output = 'Сигналов для входа не обнаружено.';
    return output;
  }

  for(const s of signals) {
    const idx = s.index;
    const type = s.type;
    const entryPrice = candlesData[idx].close;
    let stopLoss, riskPct, profitTarget, rewardPct;

    if(type === 'buy') {
      stopLoss = findLocalMin(candlesData, idx, lookback);
      if(stopLoss >= entryPrice) stopLoss = entryPrice * 0.985;
      riskPct = ((entryPrice - stopLoss) / entryPrice) * 100;
      profitTarget = entryPrice + riskPct * 2 * entryPrice / 100;
      rewardPct = ((profitTarget - entryPrice) / entryPrice) * 100;
    } else {
      stopLoss = findLocalMax(candlesData, idx, lookback);
      if(stopLoss <= entryPrice) stopLoss = entryPrice * 1.015;
      riskPct = ((stopLoss - entryPrice) / entryPrice) * 100;
      profitTarget = entryPrice - riskPct * 2 * entryPrice / 100;
      rewardPct = ((entryPrice - profitTarget) / entryPrice) * 100;
    }

    const totalCosts = commissionPct * 2;
