<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>–°–∏–≥–Ω–∞–ª—ã EMA + MACD (–¥–Ω–µ–≤–Ω–æ–π)</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 900px; margin: 20px auto; padding: 10px; }
    #results { white-space: pre-wrap; background: #f4f4f4; padding: 15px; border-radius: 8px; }
  </style>
</head>
<body>
  <h2>–ê–∫—Ç–∏–≤–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã EMA + MACD (–¥–Ω–µ–≤–Ω–æ–π –≥—Ä–∞—Ñ–∏–∫, —Ç–µ–∫—É—â–∏–π –º–µ—Å—è—Ü)</h2>
  <div id="results">–ó–∞–≥—Ä—É–∑–∫–∞...</div>

  <script>
    const tickers = ['SBER', 'LKOH', 'GAZP', 'MGNT', 'YNDX', 'VTBR'];
    const interval = 24; // –¥–Ω–µ–≤–Ω–æ–π
    const commissionPct = 0.1;
    const minProfitPct = 0.3;

    async function fetchCandles(ticker) {
      const now = new Date();
      const from = new Date(now.getFullYear(), now.getMonth(), 1).toISOString().slice(0, 10);
      const till = new Date().toISOString().slice(0, 10);
      const url = `https://iss.moex.com/iss/engines/stock/markets/shares/boards/TQBR/securities/${ticker}/candles.json?interval=${interval}&from=${from}&till=${till}&sort_order=asc&limit=1000`;

      try {
        const res = await fetch(url);
        const json = await res.json();
        const cols = json.candles.columns;
        const data = json.candles.data;
        if (!data) return [];

        const idx = name => cols.indexOf(name);
        return data.map(row => ({
          date: new Date(row[idx('begin')]),
          open: row[idx('open')],
          high: row[idx('high')],
          low: row[idx('low')],
          close: row[idx('close')],
          volume: row[idx('volume')]
        }));
      } catch (e) {
        console.error(`–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ ${ticker}:`, e);
        return [];
      }
    }

    function calculateEMA(data, period) {
      const k = 2 / (period + 1);
      const ema = [data[0].close];
      for (let i = 1; i < data.length; i++) {
        ema.push(data[i].close * k + ema[i - 1] * (1 - k));
      }
      return ema;
    }

    function calculateMACD(data, fast = 6, slow = 13, signal = 9) {
      const emaFast = calculateEMA(data, fast);
      const emaSlow = calculateEMA(data, slow);
      const macd = emaFast.map((v, i) => v - emaSlow[i]);
      const signalLine = calculateEMA(macd.map(val => ({close: val})), signal);
      return {macd, signalLine};
    }

    function findSignals(data, emaShort, emaLong, macd, signalLine) {
      const signals = [];
      for (let i = 1; i < data.length; i++) {
        const emaCrossUp = emaShort[i - 1] < emaLong[i - 1] && emaShort[i] > emaLong[i];
        const emaCrossDown = emaShort[i - 1] > emaLong[i - 1] && emaShort[i] < emaLong[i];
        const macdCrossUp = macd[i - 1] < signalLine[i - 1] && macd[i] > signalLine[i];
        const macdCrossDown = macd[i - 1] > signalLine[i - 1] && macd[i] < signalLine[i];

        if (emaCrossUp || macdCrossUp) signals.push({index: i, type: 'buy'});
        else if (emaCrossDown || macdCrossDown) signals.push({index: i, type: 'sell'});
      }
      return signals;
    }

    function findLocalExtreme(data, index, lookback, type) {
      let val = data[index][type];
      for (let i = Math.max(0, index - lookback); i < index; i++) {
        if (type === 'low' && data[i].low < val) val = data[i].low;
        if (type === 'high' && data[i].high > val) val = data[i].high;
      }
      return val;
    }

    function isSignalActive(data, index, entryPrice, target, stop, type) {
      for (let i = index + 1; i < data.length; i++) {
        const d = data[i];
        if (type === 'buy') {
          if (d.low <= stop || d.high >= target) return false;
        } else {
          if (d.high >= stop || d.low <= target) return false;
        }
      }
      return true;
    }

    function analyzeSignals(ticker, data) {
  const emaShort = calculateEMA(data, 5);
  const emaLong = calculateEMA(data, 15);
  const { macd, signalLine } = calculateMACD(data);
  const signals = findSignals(data, emaShort, emaLong, macd, signalLine);
  const lookback = 10;

  const capital = 100000;             // –∫–∞–ø–∏—Ç–∞–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  const riskPerTradePct = 1;          // —Ä–∏—Å–∫ –Ω–∞ –æ–¥–Ω—É —Å–¥–µ–ª–∫—É (%)
  const maxRisk = capital * (riskPerTradePct / 100);

  let output = '';

  for (const s of signals) {
    const idx = s.index;
    const entry = data[idx].close;
    let stop, riskPct, target, rewardPct;

    if (s.type === 'buy') {
      stop = findLocalExtreme(data, idx, lookback, 'low');
      if (stop >= entry) stop = entry * 0.985;
      riskPct = ((entry - stop) / entry) * 100;
      target = entry + riskPct * 2 * entry / 100;
      rewardPct = ((target - entry) / entry) * 100;
    } else {
      stop = findLocalExtreme(data, idx, lookback, 'high');
      if (stop <= entry) stop = entry * 1.015;
      riskPct = ((stop - entry) / entry) * 100;
      target = entry - riskPct * 2 * entry / 100;
      rewardPct = ((entry - target) / entry) * 100;
    }

    const netReward = rewardPct - commissionPct * 2;
    if (netReward < minProfitPct) continue;

    if (isSignalActive(data, idx, entry, target, stop, s.type)) {
      const riskPerShare = Math.abs(entry - stop);
      const qty = Math.floor(maxRisk / riskPerShare); // —Å–∫–æ–ª—å–∫–æ –º–æ–∂–Ω–æ –∫—É–ø–∏—Ç—å
      const totalCost = qty * entry;

      output += `üü¢ ${ticker} ‚Äî ${s.type.toUpperCase()} @ ${entry.toFixed(2)} (${data[idx].date.toISOString().slice(0, 10)})\n`;
      output += `‚Ä¢ –°—Ç–æ–ø-–ª–æ—Å—Å: ${stop.toFixed(2)} (${riskPct.toFixed(2)}%)\n`;
      output += `‚Ä¢ –¢–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç: ${target.toFixed(2)} (${rewardPct.toFixed(2)}%)\n`;
      output += `‚Ä¢ –†–∏—Å–∫ –Ω–∞ 1 –±—É–º–∞–≥—É: ${riskPerShare.toFixed(2)} —Ä—É–±\n`;
      output += `‚Ä¢ –ú–∞–∫—Å. —Ä–∏—Å–∫: ${maxRisk.toFixed(2)} —Ä—É–± (${riskPerTradePct}% –æ—Ç –∫–∞–ø–∏—Ç–∞–ª–∞)\n`;
      output += `‚Ä¢ –ö–æ–ª-–≤–æ –±—É–º–∞–≥: ${qty} —à—Ç (–Ω–∞ —Å—É–º–º—É ~${totalCost.toFixed(2)} —Ä—É–±)\n`;
      output += `‚Ä¢ ${s.type === 'buy' ? '–ü–æ–∫—É–ø–∞—Ç—å' : '–ü—Ä–æ–¥–∞–≤–∞—Ç—å'} –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å\n\n`;
    }
  }

  return output;
}

    async function runFullScan() {
      const resultsDiv = document.getElementById('results');
      resultsDiv.textContent = '–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ...';

      let fullOutput = '';
      for (const ticker of tickers) {
        const data = await fetchCandles(ticker);
        if (data.length < 20) continue;

        const analysis = analyzeSignals(ticker, data);
        if (analysis) fullOutput += analysis + '\n';
      }

      resultsDiv.textContent = fullOutput || '–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞ —Ç–µ–∫—É—â–∏–π –º–µ—Å—è—Ü.';
    }

    runFullScan();
    setInterval(runFullScan, 60 * 1000); // –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
  </script>
</body>
</html>
