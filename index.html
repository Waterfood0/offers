<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–ê–∫—Ç—É–∞–ª—å–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã (EMA + MACD)</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 900px; margin: 20px auto; padding: 10px; }
    button { margin: 5px 5px 10px 0; padding: 6px 12px; cursor: pointer; }
    #allSignals, #results {
      white-space: pre-wrap;
      background: #f9f9f9;
      padding: 15px;
      border-radius: 6px;
      margin-top: 10px;
    }
    h2 { margin-bottom: 5px; }
    .section { margin-top: 20px; }
  </style>
</head>
<body>

<h2>üìä –ê–∫—Ç—É–∞–ª—å–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã —ç—Ç–æ–≥–æ –º–µ—Å—è—Ü–∞ (–≤—Å–µ –∞–∫—Ü–∏–∏)</h2>
<div id="allSignals">–ó–∞–≥—Ä—É–∑–∫–∞...</div>

<div class="section">
  <h3>–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–∫–µ—Ä –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞:</h3>
  <div id="tickerButtons"></div>
  <div id="results"></div>
</div>

<script>
const tickers = ['SBER', 'GAZP', 'LKOH', 'MGNT', 'YNDX'];
let interval = '60';
let allData = {};
let allActiveSignals = {};
let updateTimer = null;

async function fetchDataForTicker(ticker) {
  const now = new Date();
  const currentYear = now.getFullYear();
  const url = `https://iss.moex.com/iss/engines/stock/markets/shares/boards/TQBR/securities/${ticker}/candles.json?interval=${interval}&from=${currentYear}-01-01&till=${currentYear}-12-31&sort_order=asc&limit=1000`;
  try {
    const res = await fetch(url);
    const json = await res.json();
    if (!json.candles?.data) return [];
    const cols = json.candles.columns;
    const data = json.candles.data;
    const idx = (name) => cols.indexOf(name);

    return data.map(row => ({
      date: new Date(row[idx('begin')]),
      open: row[idx('open')],
      high: row[idx('high')],
      low: row[idx('low')],
      close: row[idx('close')],
      volume: row[idx('volume')]
    }));
  } catch (e) {
    console.error(`–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ ${ticker}`, e);
    return [];
  }
}

function calculateEMA(data, period) {
  const k = 2 / (period + 1);
  const emaArray = [];
  let emaPrev = data[0].close;
  for (let i = 0; i < data.length; i++) {
    emaPrev = i === 0 ? emaPrev : data[i].close * k + emaPrev * (1 - k);
    emaArray.push(emaPrev);
  }
  return emaArray;
}

function calculateMACD(data, fast = 6, slow = 13, signal = 9) {
  const emaFast = calculateEMA(data, fast);
  const emaSlow = calculateEMA(data, slow);
  const macdLine = emaFast.map((v, i) => v - emaSlow[i]);
  const signalLine = calculateEMA(macdLine.map(v => ({ close: v })), signal);
  return { macdLine, signalLine };
}

function findSignals(data, emaShort, emaLong, macdLine, signalLine) {
  const signals = [];
  for (let i = 1; i < emaShort.length; i++) {
    const emaUp = emaShort[i - 1] < emaLong[i - 1] && emaShort[i] > emaLong[i];
    const emaDown = emaShort[i - 1] > emaLong[i - 1] && emaShort[i] < emaLong[i];
    const macdUp = macdLine[i - 1] < signalLine[i - 1] && macdLine[i] > signalLine[i];
    const macdDown = macdLine[i - 1] > signalLine[i - 1] && macdLine[i] < signalLine[i];
    if (emaUp || macdUp) signals.push({ index: i, type: 'buy' });
    else if (emaDown || macdDown) signals.push({ index: i, type: 'sell' });
  }
  return signals;
}

function findLocalMin(data, i, lookback = 10) {
  return Math.min(...data.slice(Math.max(0, i - lookback), i).map(d => d.low));
}

function findLocalMax(data, i, lookback = 10) {
  return Math.max(...data.slice(Math.max(0, i - lookback), i).map(d => d.high));
}

function findExit(data, startIdx, tp, sl, type) {
  for (let i = startIdx + 1; i < data.length; i++) {
    if (type === 'buy') {
      if (data[i].low <= sl) return { date: data[i].date, reason: '–°—Ç–æ–ø-–ª–æ—Å—Å' };
      if (data[i].high >= tp) return { date: data[i].date, reason: '–¢–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç' };
    } else {
      if (data[i].high >= sl) return { date: data[i].date, reason: '–°—Ç–æ–ø-–ª–æ—Å—Å' };
      if (data[i].low <= tp) return { date: data[i].date, reason: '–¢–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç' };
    }
  }
  return { date: null };
}

function isCurrentMonth(date) {
  const now = new Date();
  return date.getFullYear() === now.getFullYear() && date.getMonth() === now.getMonth();
}

function analyze(data, signals) {
  const results = [];
  for (const s of signals) {
    const i = s.index;
    const entry = data[i].close;
    const date = data[i].date;
    if (!isCurrentMonth(date)) continue;

    let stop, tp;
    if (s.type === 'buy') {
      stop = findLocalMin(data, i);
      stop = stop >= entry ? entry * 0.985 : stop;
      const risk = entry - stop;
      tp = entry + risk * 2;
    } else {
      stop = findLocalMax(data, i);
      stop = stop <= entry ? entry * 1.015 : stop;
      const risk = stop - entry;
      tp = entry - risk * 2;
    }

    const exit = findExit(data, i, tp, stop, s.type);
    if (!exit.date) {
      results.push({
        date: date.toISOString().slice(0, 10),
        entry: entry.toFixed(2),
        stop: stop.toFixed(2),
        tp: tp.toFixed(2),
        type: s.type
      });
    }
  }
  return results;
}

function renderSignalBlock(ticker, signals) {
  if (signals.length === 0) return `${ticker}: –ù–µ—Ç –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤\n`;
  return signals.map(s =>
    `${ticker} | ${s.type.toUpperCase()} | ${s.date}\n–¶–µ–Ω–∞: ${s.entry}, –°—Ç–æ–ø: ${s.stop}, –¶–µ–ª—å: ${s.tp}\n`
  ).join('\n');
}

async function updateAll() {
  const allDiv = document.getElementById('allSignals');
  allDiv.textContent = '–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ...';
  allActiveSignals = {};
  const allOutput = [];

  for (const ticker of tickers) {
    const data = await fetchDataForTicker(ticker);
    allData[ticker] = data;

    const emaShort = calculateEMA(data, 5);
    const emaLong = calculateEMA(data, 15);
    const { macdLine, signalLine } = calculateMACD(data);

    const signals = findSignals(data, emaShort, emaLong, macdLine, signalLine);
    const active = analyze(data, signals);
    allActiveSignals[ticker] = active;

    allOutput.push(renderSignalBlock(ticker, active));
  }

  const time = new Date().toLocaleTimeString();
  allDiv.textContent = allOutput.join('\n') + `\n–û–±–Ω–æ–≤–ª–µ–Ω–æ: ${time}`;
}

function setupTickerButtons() {
  const buttonWrap = document.getElementById('tickerButtons');
  buttonWrap.innerHTML = '';
  for (const ticker of tickers) {
    const btn = document.createElement('button');
    btn.textContent = ticker;
    btn.onclick = () => {
      const out = renderSignalBlock(ticker, allActiveSignals[ticker] || []);
      document.getElementById('results').textContent = out || '–ù–µ—Ç —Å–∏–≥–Ω–∞–ª–æ–≤';
    };
    buttonWrap.appendChild(btn);
  }
}

function startAutoRefresh() {
  if (updateTimer) clearInterval(updateTimer);
  updateTimer = setInterval(updateAll, 60 * 1000); // –∫–∞–∂–¥—ã–µ 60 —Å–µ–∫
}

async function init() {
  setupTickerButtons();
  await updateAll();
  startAutoRefresh();
}

init();
</script>

</body>
</html>
