<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>Технический анализ SBER</title>
<style>
  body { font-family: Arial, sans-serif; max-width: 700px; margin: 20px auto; padding: 10px; }
  button { margin-right: 10px; padding: 7px 14px; cursor: pointer; }
  input { width: 70px; padding: 5px; margin-right: 10px; }
  #status { margin: 15px 0; font-weight: bold; }
  #results { white-space: pre-wrap; background: #f9f9f9; padding: 15px; border-radius: 6px; min-height: 200px; }
</style>
</head>
<body>

<h2>Технический анализ SBER (часовой / дневной)</h2>

<div>
  <button onclick="selectInterval('60')">Часовой</button>
  <button onclick="selectInterval('24')">Дневной</button>
</div>

<div style="margin-top:15px;">
  <label>Комиссия %: <input type="number" id="commission" step="0.01" value="0.1"></label>
  <label>Мин. прибыль %: <input type="number" id="minProfit" step="0.01" value="0.3"></label>
  <button onclick="runAnalysis()">Запустить анализ</button>
</div>

<p id="status">Выберите интервал и нажмите "Запустить анализ"</p>

<div id="results"></div>

<script>
let interval = '60'; // по умолчанию часовой
let candlesData = [];

function selectInterval(val) {
  interval = val;
  document.getElementById('status').textContent = `Выбран интервал: ${interval === '24' ? 'Дневной' : 'Часовой'}`;
  document.getElementById('results').textContent = '';
}

async function fetchData() {
  candlesData = [];
  const years = [2021, 2022, 2023, 2024, 2025];
  const ticker = 'SBER';

  for (const year of years) {
    const from = `${year}-01-01`;
    const till = `${year}-12-31`;
    const url = `https://iss.moex.com/iss/engines/stock/markets/shares/boards/TQBR/securities/${ticker}/candles.json?interval=${interval}&from=${from}&till=${till}&sort_order=asc&limit=1000`;
    try {
      const res = await fetch(url);
      const json = await res.json();
      if (!json.candles || !json.candles.data) continue;
      const cols = json.candles.columns;
      const data = json.candles.data;
      const dateIdx = cols.indexOf('begin');
      const openIdx = cols.indexOf('open');
      const highIdx = cols.indexOf('high');
      const lowIdx = cols.indexOf('low');
      const closeIdx = cols.indexOf('close');
      const volumeIdx = cols.indexOf('volume');

      const yearData = data.map(row => ({
        date: new Date(row[dateIdx]),
        open: row[openIdx],
        high: row[highIdx],
        low: row[lowIdx],
        close: row[closeIdx],
        volume: row[volumeIdx]
      }));
      candlesData = candlesData.concat(yearData);
    } catch(e) {
      console.error(`Ошибка загрузки данных за ${year}`, e);
    }
  }
}

function calculateSMA(data, period) {
  const sma = [];
  for(let i = 0; i < data.length; i++) {
    if(i < period - 1) {
      sma.push(null);
      continue;
    }
    let sum = 0;
    for(let j = i - period + 1; j <= i; j++) {
      sum += data[j].close;
    }
    sma.push(sum / period);
  }
  return sma;
}

function findCrossovers(shortSMA, longSMA) {
  const signals = [];
  for(let i = 1; i < shortSMA.length; i++) {
    if(shortSMA[i-1] === null || longSMA[i-1] === null) continue;
    if(shortSMA[i-1] < longSMA[i-1] && shortSMA[i] > longSMA[i]) {
      signals.push({ index: i, type: 'buy' });
    } else if(shortSMA[i-1] > longSMA[i-1] && shortSMA[i] < longSMA[i]) {
      signals.push({ index: i, type: 'sell' });
    }
  }
  return signals;
}

function findLocalMin(data, startIdx, length) {
  let min = data[startIdx].low;
  for(let i = startIdx; i > startIdx - length && i >= 0; i--) {
    if(data[i].low < min) min = data[i].low;
  }
  return min;
}

function findLocalMax(data, startIdx, length) {
  let max = data[startIdx].high;
  for(let i = startIdx; i > startIdx - length && i >= 0; i--) {
    if(data[i].high > max) max = data[i].high;
  }
  return max;
}

function findExitDate(data, startIdx, targetPrice, stopPrice, type) {
  for(let i = startIdx + 1; i < data.length; i++) {
    if(type === 'buy') {
      if(data[i].low <= stopPrice) return {date: data[i].date, reason: 'Стоп-лосс достигнут'};
      if(data[i].high >= targetPrice) return {date: data[i].date, reason: 'Тейк-профит достигнут'};
    } else {
      if(data[i].high >= stopPrice) return {date: data[i].date, reason: 'Стоп-лосс достигнут'};
      if(data[i].low <= targetPrice) return {date: data[i].date, reason: 'Тейк-профит достигнут'};
    }
  }
  return {date: null, reason: 'Позиция открыта до последней свечи'};
}

function analyzeSignals(signals, commissionPct, minProfitPct) {
  const lookback = 10;
  let output = '';

  if(signals.length === 0) {
    output = 'Сигналов для входа не обнаружено.';
    return output;
  }

  for(const s of signals) {
    const idx = s.index;
    const type = s.type;
    const entryPrice = candlesData[idx].close;
    let stopLoss, riskPct, profitTarget, rewardPct;

    if(type === 'buy') {
      stopLoss = findLocalMin(candlesData, idx, lookback);
      if(stopLoss >= entryPrice) stopLoss = entryPrice * 0.985;
      riskPct = ((entryPrice - stopLoss) / entryPrice) * 100;
      profitTarget = entryPrice + riskPct * 2 * entryPrice / 100;
      rewardPct = ((profitTarget - entryPrice) / entryPrice) * 100;
    } else {
      stopLoss = findLocalMax(candlesData, idx, lookback);
      if(stopLoss <= entryPrice) stopLoss = entryPrice * 1.015;
      riskPct = ((stopLoss - entryPrice) / entryPrice) * 100;
      profitTarget = entryPrice - riskPct * 2 * entryPrice / 100;
      rewardPct = ((entryPrice - profitTarget) / entryPrice) * 100;
    }

    // Учитываем комиссию (вход и выход)
    const totalCosts = commissionPct * 2;
    if(rewardPct < minProfitPct || rewardPct < totalCosts) {
      output += `\nСигнал на ${type.toUpperCase()} (${candlesData[idx].date.toLocaleString()}): прибыль (${rewardPct.toFixed(2)}%) меньше минимальной или не покрывает комиссию.\n`;
      continue;
    }

    const exitInfo = findExitDate(candlesData, idx, profitTarget, stopLoss, type);
    const exitDateStr = exitInfo.date ? exitInfo.date.toLocaleString() : 'не достигнута';
    output += `\nСигнал на ${type.toUpperCase()} (${candlesData[idx].date.toLocaleString()}):\n`;
    output += `  Цена входа: ${entryPrice.toFixed(2)} ₽\n`;
    output += `  Стоп-лосс: ${stopLoss.toFixed(2)} ₽ (${riskPct.toFixed(2)}% риска)\n`;
    output += `  Цель: ${profitTarget.toFixed(2)} ₽ (${rewardPct.toFixed(2)}% прибыли)\n`;
    output += `  Выход: ${exitDateStr} (${exitInfo.reason})\n`;
  }

  return output || 'Сигналов для входа не обнаружено.';
}

async function runAnalysis() {
  document.getElementById('status').textContent = 'Загрузка данных... Подождите.';
  document.getElementById('results').textContent = '';
  await fetchData();
  if(candlesData.length === 0) {
    document.getElementById('status').textContent = 'Данные не загружены.';
    return;
  }
  document.getElementById('status').textContent = `Данные загружены: ${candlesData.length} свечей. Анализируем...`;

  const commission = parseFloat(document.getElementById('commission').value) || 0;
  const minProfit = parseFloat(document.getElementById('minProfit').value) || 0;

  const sma10 = calculateSMA(candlesData, 10);
  const sma50 = calculateSMA(candlesData, 50);
  const signals = findCrossovers(sma10, sma50);
  const analysis = analyzeSignals(signals, commission, minProfit);

  document.getElementById('results').textContent = analysis;
  document.getElementById('status').textContent = 'Анализ завершён.';
}
</script>

</body>
</html>
