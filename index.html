<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Дневной анализ SBER</title>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; max-width: 600px; margin: auto; }
  #price { font-size: 2em; margin-bottom: 10px; }
  #signalsToggle { margin: 10px 0; cursor: pointer; color: blue; text-decoration: underline; }
  #signalsList { display: none; border: 1px solid #ccc; padding: 10px; margin-bottom: 20px; max-height: 200px; overflow-y: auto; background: #f9f9f9;}
  #notification { border: 2px solid #f39c12; background: #fff8e1; padding: 15px; margin-bottom: 20px; display: none; }
  #notification button { margin-top: 10px; }
</style>
</head>
<body>

<h1>Акция SBER (Дневной анализ)</h1>
<div id="price">Текущая цена: ...</div>

<div id="notification">
  <div id="notificationText"></div>
  <button id="btnOk">ОК</button>
</div>

<div id="signalsToggle">Показать последние 3 сделки</div>
<div id="signalsList"></div>

<div>
  <label>Комиссия (%): <input type="number" id="commission" value="0.1" step="0.01" min="0" max="10"/></label>
  <label>Минимальная прибыль (%): <input type="number" id="minProfit" value="0.3" step="0.01" min="0" max="100"/></label>
  <button id="btnAnalyze">Запустить анализ</button>
</div>

<pre id="results" style="white-space: pre-wrap; background: #eee; padding: 10px; margin-top:20px; max-height:300px; overflow-y:auto;"></pre>

<script>
// Заглушка для данных — имитация 100 дней с рандомом
let candlesData = [];

async function fetchData() {
  const startDate = new Date(2021, 0, 1);
  candlesData = [];
  let price = 250;
  for(let i = 0; i < 100; i++) {
    const date = new Date(startDate);
    date.setDate(startDate.getDate() + i);
    const open = price * (1 + (Math.random() - 0.5) / 100);
    const close = open * (1 + (Math.random() - 0.5) / 100);
    const high = Math.max(open, close) * (1 + Math.random() / 100);
    const low = Math.min(open, close) * (1 - Math.random() / 100);
    price = close;
    candlesData.push({date, open, close, high, low});
  }
}

function calculateEMA(data, period) {
  const k = 2 / (period + 1);
  const emaArray = [];
  let emaPrev = data[0].close;
  emaArray[0] = emaPrev;
  for(let i = 1; i < data.length; i++) {
    emaPrev = data[i].close * k + emaPrev * (1 - k);
    emaArray.push(emaPrev);
  }
  return emaArray;
}

function calculateMACD(data, fastPeriod = 6, slowPeriod = 13, signalPeriod = 9) {
  const emaFast = calculateEMA(data, fastPeriod);
  const emaSlow = calculateEMA(data, slowPeriod);
  const macdLine = [];
  for(let i = 0; i < data.length; i++) {
    macdLine.push(emaFast[i] - emaSlow[i]);
  }
  const signalLine = calculateEMA(macdLine.map(val => ({close: val})), signalPeriod);
  return {macdLine, signalLine};
}

function findSignals(emaShort, emaLong, macdLine, signalLine) {
  const signals = [];
  for(let i = 1; i < emaShort.length; i++) {
    if(emaShort[i-1] === undefined || emaLong[i-1] === undefined) continue;
    if(macdLine[i-1] === undefined || signalLine[i-1] === undefined) continue;

    const emaCrossUp = (emaShort[i-1] < emaLong[i-1]) && (emaShort[i] > emaLong[i]);
    const emaCrossDown = (emaShort[i-1] > emaLong[i-1]) && (emaShort[i] < emaLong[i]);
    const macdCrossUp = (macdLine[i-1] < signalLine[i-1]) && (macdLine[i] > signalLine[i]);
    const macdCrossDown = (macdLine[i-1] > signalLine[i-1]) && (macdLine[i] < signalLine[i]);

    if(emaCrossUp || macdCrossUp) signals.push({index: i, type: 'buy'});
    else if(emaCrossDown || macdCrossDown) signals.push({index: i, type: 'sell'});
  }
  return signals;
}

function findLocalMin(data, index, lookback = 10) {
  let minVal = data[index].low;
  for(let i = Math.max(0, index - lookback); i < index; i++) {
    if(data[i].low < minVal) minVal = data[i].low;
  }
  return minVal;
}
function findLocalMax(data, index, lookback = 10) {
  let maxVal = data[index].high;
  for(let i = Math.max(0, index - lookback); i < index; i++) {
    if(data[i].high > maxVal) maxVal = data[i].high;
  }
  return maxVal;
}

function analyzeSignals(signals, commissionPct, minProfitPct) {
  const lookback = 10;
  let output = '';

  if(signals.length === 0) {
    output = 'Сигналов для входа не обнаружено.';
    return output;
  }

  for(const s of signals.slice(-3)) {
    const idx = s.index;
    const type = s.type;
    const entryPrice = candlesData[idx].close;
    let stopLoss, riskPct, profitTarget, rewardPct;

    if(type === 'buy') {
      stopLoss = findLocalMin(candlesData, idx, lookback);
      if(stopLoss >= entryPrice) stopLoss = entryPrice * 0.985;
      riskPct = ((entryPrice - stopLoss) / entryPrice) * 100;
      profitTarget = entryPrice + riskPct * 2 * entryPrice / 100;
      rewardPct = ((profitTarget - entryPrice) / entryPrice) * 100;
    } else {
      stopLoss = findLocalMax(candlesData, idx, lookback);
      if(stopLoss <= entryPrice) stopLoss = entryPrice * 1.015;
      riskPct = ((stopLoss - entryPrice) / entryPrice) * 100;
      profitTarget = entryPrice - riskPct * 2 * entryPrice / 100;
      rewardPct = ((entryPrice - profitTarget) / entryPrice) * 100;
    }

    const totalCosts = commissionPct * 2;
    if (rewardPct - totalCosts < minProfitPct) {
      output += `Сигнал #${idx} (${type.toUpperCase()}): Прибыль ниже минимальной с учётом комиссии. Пропускаем.\n\n`;
      continue;
    }

    output += `Сигнал #${idx} (${type.toUpperCase()}):\n` +
              `Дата входа: ${candlesData[idx].date.toISOString().slice(0,10)}\n` +
              `Цена входа: ${entryPrice.toFixed(2)}\n` +
              `Стоп-лосс: ${stopLoss.toFixed(2)} (${riskPct.toFixed(2)}%)\n` +
              `Тейк-профит: ${profitTarget.toFixed(2)} (${rewardPct.toFixed(2)}%)\n\n`;
  }
  return output;
}

// --- Показ/скрытие сделок ---
const signalsToggle = document.getElementById('signalsToggle');
const signalsList = document.getElementById('signalsList');

signalsToggle.onclick = () => {
  if(signalsList.style.display === 'none') {
    signalsList.style.display = 'block';
    signalsToggle.textContent = 'Скрыть последние 3 сделки';
  } else {
    signalsList.style.display = 'none';
    signalsToggle.textContent = 'Показать последние 3 сделки';
  }
};

// --- Обновление цены и анализ ---
async function runAnalysis() {
  document.getElementById('price').textContent = 'Текущая цена: ...';
  document.getElementById('results').textContent = '';
  await fetchData();

  if(candlesData.length === 0) {
    document.getElementById('price').textContent = 'Данные не загружены';
    return;
  }

  const lastCandle = candlesData[candlesData.length - 1];
  document.getElementById('price').textContent = `Текущая цена: ${lastCandle.close.toFixed(2)} ₽ (${lastCandle.date.toISOString().slice(0,10)})`;

  const commissionPct = parseFloat(document.getElementById('commission').value) || 0;
  const minProfitPct = parseFloat(document.getElementById('minProfit').value) || 0;

  const emaShort = calculateEMA(candlesData, 3);
  const emaLong = calculateEMA(candlesData, 8);
  const {macdLine, signalLine} = calculateMACD(candlesData, 6, 13, 9);
  const signals = findSignals(emaShort, emaLong, macdLine, signalLine);

  // Отобразить последние 3 сделки рядом
  let last3Signals = signals.slice(-3);
  signalsList.innerHTML = '';
  if(last3Signals.length === 0
